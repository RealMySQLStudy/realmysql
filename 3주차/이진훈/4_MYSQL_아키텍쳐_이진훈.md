# 4장 MySQL 아키텍쳐

## 장점

- 저비용
- 오픈소스

## 전체 구조

프로그래밍 API (자바 등) ↔ MySQL 엔진 ↔ 스토리지 엔진 ↔ 운영체제 하드웨어

- 구조 그림
    
    ![스크린샷 2023-10-04 오후 1.32.04.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/18783b10-0418-4579-a456-fda2c72cd5ee/447614a7-bc85-4b61-8850-da479db7fdd6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.32.04.png)
    

### MySQL 엔진

- 커넥션 핸들러
    - 클라언트 *접속 및 쿼리* 처리
- SQL 파서 & 전처리기
- 옵티마이저
    - 쿼리 최적화된 실행 담당

### 스토리지 엔진

- 실제 데이터를 스토리지에 저장하거나 읽는 부분을 담당 (RW)
- 스토리지 엔진은 여러개 사용가능
- 예시)
    - `create table test_table (fd1 INT, fd2 INT) ENGINE=INNODB;`
- 종류: MyISAM 엔진, InnoDB 엔진

### 핸들러 API

- MySQL 엔진과 스토리지 엔진의 데이터 교환에 쓰임
- `SHOW GLOBAL STATUS LIKE 'Handler%';`

## 쓰레딩 구조

- 그림
    
    ![스크린샷 2023-10-04 오후 1.43.30.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/18783b10-0418-4579-a456-fda2c72cd5ee/5106c3c1-e960-4d9e-a163-f406ddefc9dc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.43.30.png)
    

### 포그라운드 쓰레드

- 접속된 클라이언트 당 하나의 스레드 존재
- 클라이언트가 작업을 마치면 스레드 캐시로 돌아감
    - 이때 스레드 캐시에 이미 많은 양의 스레드가 명령을 대기 중이면 스레드를 ****종료****시킴
- 데이터를 가져오는 역할 *(Read)*
    - 데이터 버퍼나 캐시로 부터 가져옴
    - 캐시나 버퍼가 비어있을 경우 직접 데이터나 인덱스를 읽음
- MyISAM 은 ******Write****** 또한 담당
- InnoDB 는 write 을 백그라운드가 담당 (버퍼 →디스크)

### 백그라운드 쓰레드

- InnoDB 만 해당
- 백그라운드 작업의 종류
    - 인서트 버퍼 병합
    - 로그를 디스크로 기록
    - InnoDB 버퍼 풀의 데이터를 디스크에 기록
    - 데이터를 버퍼로 읽어오는 과정
    - 데드락 모니터링
- 쓰기 쓰레드는 많은 것이 좋음
    - 일반적으로 2~4개
    - DAS나 SAN은 디스크의 최적만큼
- *Write 을 백그라운드에서 진행 → 기다리지 않아도 된다고 생각하면 됨*
    - 반대로 MyISAM은 기다려야함

## 메모리 할당 및 사용 구조

- 글로벌 메모리 영역 & 로컬(세션) 메모리 영역으로 구분

### 글로벌 메모리 영역

- 모든 쓰레드가 공유함
- 종류
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB redo 로그 버퍼

### 로컬 메모리 영역

- 쿼리를 처리하는데에 사용하는 메모리 영역
    - 커넥션 버퍼 (커넥션 당 한 메모리 영역)
    - 정렬 소트 버퍼

### 플러그인 엔진 모델

- 특정 기능을 플러그인 개발 해서 사용가능
- ex) 스토리지 엔진
- `show plugins;`
- 단점이 몇가지 있어서 컴포넌트로 대체

### 쿼리 실행 구조

- 그림
    
    ![스크린샷 2023-10-05 오전 9.30.10.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/18783b10-0418-4579-a456-fda2c72cd5ee/26a9c3a1-7b24-42c3-9696-e4d0c2a2c3bb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-05_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.30.10.png)
    
- 쿼리 파서 : 사용자의 요청을 토큰 형태으로 구분해 트리를 만듦
    - 테이블, 컬럼이름, 내장 함수와 같은 객체 맵핑 → 문법오류를 확인
- 전처리기 : 쿼리 문장에 구조적 문제점 확인 : 존재하지 않거나, 사용할 수 없는 토큰이 걸러짐
- 옵티마이저 : 쿼리문장을 저렴한 비용으로 처리하는 방법 결정 → 이 책의 메인주제
- 실행엔진 : 중간관리자 → 핸들러에 명령을 내림
- 핸들러 (스토리지 엔진) : 디스크에서 읽어오는 역할

### 쓰레드 풀

- 내부적으로 쓰레드의 개수를 줄임 (CPU개수 만큼) → CPU가 제한된 쓰레드의 처리에만 집중할 수 있게 함
- CPU Time 이 길어야 위의 전략이 유효함
    - 반대의 경우 오히려 속도가 느려짐
    - 프로세서 친화도를 높이고, 컨텍스트 스위치를 줄일 수 있음

### 트랜잭션을 위한 메타데이터

- 기존에는 파일기반으로 메타데이터를 관리함
    - 이는 트랜잭션을 지원하지 못함
    - MySQL 서버의 비정상 종료 → 일관되지 않은 데이터
- 이를 InnoDB 테이블에 저장하여 개선 → `mysql.idb` 에 MySQL 테이블들이 저장됨
    - InnoDB 이외에는 파일기반 → JSON 덤프

# InnoDB 아키텍처

- InnoDB 구조
    
    ![스크린샷 2023-10-11 오전 10.41.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/18783b10-0418-4579-a456-fda2c72cd5ee/991a6898-0054-45a5-8fbb-01bf61972c09/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.41.54.png)
    

## 언두로그

- 트랜잭션 & 격리수준 보장위해 DML **이전의 버전 데이터를 백업 (메모리저장)**
    - 트랜잭션 보장 : 롤백시 백업데이터 복구
    - 격리수준 보장 : DML시 읽기요청시, 언두 로그의 데이터를 보여줌
- 트랜잭션의 데이터가 커지면 성능저하

## 체인지버퍼

- 레코드 Insert, update 시, 데이터 파일 변경과 동시에 인덱스 업데이트 필요
- 인덱스 업데이트는 랜덤 디스크 읽기 작업 → 많은 자원소모
    - **메모리에 임시로 저장**, 사용자에게 결과 반환 → 체인지 버퍼라고 함
    - 추후 백그라운드 잡으로 머지 스레드가 병합

## 리두로그 (WAL)

- 서버가 비정상 종료되어도 데이터를 잃지않게 해주는 역할
- **실제 데이터와 트랜잭션의 종류, 상태(완료, 롤백, 진행중)를 저장**하는 것 같음 **(메모리 → 디스크저장)**
- 매번하면 성능이 안좋으니, 디스크 동기화 빈도를 설정할 수 있음

## 어댑티브 해시 인덱스

- InnoDB 스토리지 엔진이, **자주 사용되는 정보에 대해 자동으로 만든 인덱스**
- 사용자 인덱스인 B- 트리의 검색시간을 줄이기 위해 도입 →트리 서치 비용이 없음
- key: B-트리 인덱스의 id
- value: B-트리의 value
- 사용시 좋은 경우
    - 디스크 읽기가 많지 않은 경우 (버퍼풀에 데이터가 다 들어갈 경우)
    - = 연산이 많을 경우 (where =, In …)
    - 데이터가 일부에 몰려있을 경우
- 안좋은 경우
    - 디스크 읽기가 많은 경우
    - Join, LIKE 많을때
    - 폭넓게 읽는 경우

## InnoDB 버퍼 풀

- InnoDB 버퍼 풀
    - 디스크의 **데이터나 인덱스 정보를 메모리에 캐싱**
    - 쓰기작업을 지연시켜 일괄 작업으로 최적화
    - 쿼리는 보통 랜덤한 디스크 작업을 발생시킴
        - 하지만 이를 버퍼 풀(메모리)에 모아서 처리하면, 랜덤 디스크 작업을 줄일 수 있음
- InnoDB 버퍼 풀 크기 설정
    - 보통 전체 물리 메모리의 80% 사용하는 듯
        - 50%에서 시작해서 조금씩 올려갈 것
    - 하지만 MySQL 엔진의 레코드 버퍼 풀도 고려해야함
        - 클라이언트 세션마다 레코드를 읽고 쓸 때 사용하는 버퍼
        - 커넥션이 많아질 수록 비례해서 커질 수 있음
    - 버퍼 풀도 잠금이 있어서, 작은 버퍼 풀 인스턴스로 쪼개어 관리 (잠금도 여러개가 됨)
- 버퍼풀 구조
    - 메모리 구조
        - 버퍼풀을 페이지 단위로 나눔
        - 데이터가 필요할때마다 해당 페이지를 참조
    - 관리 자료구조
        - LRU 리스트
            - LRU, MRU로 나뉨
                - LRU : Old 서브리스트
                - MRU : New 서브리스트
            - 자주 사용되는 페이지를 오랫동안 메모리에 상주
                - 디스크 읽기 최소화
            - InnoDB 엔진의 데이터 찾는 과정
                
                ![스크린샷 2023-11-29 오후 4.03.52.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/18783b10-0418-4579-a456-fda2c72cd5ee/5d96dad7-43a4-4306-9cd2-04b6a07e0090/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.03.52.png)
                
                1. 레코드가 버퍼 풀 (즉 캐시에 있는지 확인) → 있다면 MRU 방향 승급
                    1. InnoDB 어댑티브 해시 인덱스 사용
                    2. 테이블의 인덱스를 이용해 버퍼 풀에서 페이지 검색
                2. (없다면) 디스크에서 Read, 버퍼풀에 적재, 페이지에 대한 포인터를 LRU의 Head에 추가
                - 오랫동안 사용되지 않으면, Aging으로 인해 버퍼풀에서 제거
                - 특정 데이터가 자주 접근 되는 경우, 해당 페이지의 인덱스를 어댑티프 해시 인덱스에 추가
        - Flush 리스트
            - 디스크로 동기화되지 않은 페이지를 관리 (더티 페이지 관리)
            - 데이터가 변경되면 일단 flush 리스트에서 관리
                - 특정 시기 이후에 1) **리두 로그**에 기록, 2) 버퍼 풀의 데이터 페이지에 반영
                    - 리두 로그는 그래서 데이터 페이지와 연결
                - 체크포인트 단위로, 디스크의 리두로그와 디스크의 데이터 페이지를 동기화 (이벤트 소싱과 비슷)
        - Free 리스트
            - 사용자 데이터가 상주하지 않는, 비어있는 페이지의 목록
            - 새롭게 디스크 페이지 읽을때 사용
- 버퍼풀과 리두로그
    - 버퍼풀에 최대한 많은 사이즈를 주면 성능이 좋아짐
        - 데이터를 많이 캐싱할 수 있음
    - 버퍼풀
        - 클린 페이지
        - 더티 페이지
            - 디스크와 버퍼의 상태가 달라, 언젠가는 flush가 되어야함
            - 리두로그는 파일에 적힘
                - 이때 파일의 순환구조를 사용하여 적힘
                - 그렇기 때문에 결국 다시 첫페이지가 덮어씌워지는 경우가 생김
            - 확성 리두 로그
                - 재사용 불가능한 공간 (덮어씌워지면 안되는)
            - LSN (log sequence number)
                - 로그의 포지션
                - 마지막 체크포인트에서 현재의 LSN까지의 페이지를 flush 하면됨 (이를 체크포인트 에이지라고 함)
    - 둘의 상관관계에 대한 예시
        - 리두 로그가, 더티페이지에 대한 메타데이터라고 생각하면됨 (쓰기를 로깅함, 일종의 scatter-gather 원리)
            
            ![스크린샷 2023-11-29 오후 6.51.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/18783b10-0418-4579-a456-fda2c72cd5ee/f8c014a6-6571-4a30-880b-5f65e404e331/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.51.54.png)
            
        1. InnoDB 버퍼풀 100GB (캐싱 엄청 많이 할 수 있음), 리두 로그 전체 크기 100MB (트랜잭션 길게 못함, 더티페이지 적어짐)
            1. 리두 로그 엔트리가 4KB → 100MB / 4KB = 25600 엔트리의 더티페이지 저장가능
            2. 데이터의 실제 크기가 16KB면 버퍼풀에는 400MB밖에 저장 못함 (99GB 공간낭비)
        2. InnoDB 버퍼풀 100MB (캐싱 엄청 조금밖에 못함), 리두 로그 전체 크기 100GB (트랜잭션 엄청 길게 할 수 있음)
            1. 같은 원리로 계산하면 오히려 버퍼풀이 부족함
        - 실제로 리두로그의 크기를 조정해가며 적정크기를 찾기
        
- 버퍼풀 플러시
    - 리두 로그 엔트리를 clean 해야할때
        - 더티 페이지가 먼저 디스크로 동기화되어야함
        - 스토리지 엔진 단에서 flush_list 를 호출해서 오래된 더티 페이지 순으로 기록
        - 이와 관련된 여러 시스템 변수들 존재
            - 클리너 쓰레드: 더티 페이지를 디스크로 동기화 시키는 쓰레드
                - 이것이 버퍼풀 인스턴스보다 많으면, 같게 자동 변경
                - 적으면 한 쓰레드가 여러 인스턴스에 대해 동기화를 시키므로, 성능에 안좋음 (가능하면 동일하게 설정할 것)
    - 전체 버퍼 풀이 가진 페이지의 90프로까지 더티 페이지를 가질 수 있게 설정되어있음
        - 더티 페이지가 많을 수록 쓰기가 벌킹되어 효율적인 쓰기임
        - 하지만 90프로에 가까우면, Disk IO burst로 안좋은 현상임
            - 이를 완화하기 위해 더티페이지 write 퍼센트 threshold 변수 제공 (기본 10%)
    - 디스크의 RW 최대 성능 횟수 변수 존재
        - 서버 트래픽에 맞게 설정할 것 (번거로움, 자세히 알 수 없음)
        - 이를 보완하기위해 `어댑티브 플러시` 기능 제공
            - 더티페이지의 생성 속도를 확인 → 10%를 지속적으로 쓰게 플러시 조정
    - LRU LIST 의 플러시
        - LRU 리스트의 Tail 부터 시스템 변수만큼 스캔
        - 클린 → 즉시 제거
        - 더티 → 플러시
- 버퍼 풀 상태 백업 및 복구
    - 워밍업 상태 : 쿼리들의 대상 페이지들이 버퍼풀에 이미 적재되어있는 상태 → 성능이 몇십배 좋음
    - 워밍업 상태를 유지하기 위해 버퍼풀 상태 백업가능
- 버퍼 풀 내용확인
    - 버퍼 풀에 어떤 테이블의 페이지가 있는지 확인가능 → 부하가 큼
    - 테이블의 인덱스 별로 페이지 적재 확인가능 → 권장

## InnoDB 스토리지 엔진 특징

- 테이블은 프라이머리 키를 기준으로 클러스터링되어 저장
    - 테이블 내에서 프라이머리 키 값 순으로 디스크에 저장
    - PK를 이용한 레인지 스캔이 빠름
        - 반대로 MyISAM은 PK 클러스터링이 없기 때문에 프라이머리 키와 세컨더리 인덱스와 같음 (PK는 unique 제약이 있다는 것만 다름)
- 외래 키 지원
    - MyISAM은 지원 x
    - 외래 키는, 부모 자식 테이블 모두 인덱스를 만드는 오버헤드 존재
    - 변경시 무결성을 위해 부모, 자식에 락이 전파되고 데이터를 검사하므로 데드락 주의
        - 외래키를 일시적으로 비활성화 가능 → 관련 데이터 지우고 활성화 하기
- MVCC(Multi Version Concurrency Control)
    - 잠금을 사용하지 않는, 일관된 읽기
        - 레코드 레벨의 트랜잭션 지원하는 DBMS가 지원
        - **Undo log** 를 통해 구현
    - 여러 버전의 레코드가 동시에 관리
        - 예시
            1. {id:12, name:’홍길동’, area:’서울’} 이라는 레코드 삽입
                1. 이때 버퍼풀과 디스크에 해당 내용이 저장되어있음
            2. area 를 ‘경기’로 변경하는 update 쿼리 전송
                1. 버퍼풀에는 {id:12, name:’홍길동’, area:’경기’} 저장
                2. 디스크에는 {id:12, name:’홍길동’, area:’경기’}가 저장될 확률이 높음 (acid)
                3. undo log 에는 여전히 {id:12, name:’홍길동’, area:’서울’} 를 저장
            3. 커밋이 아직 안되어있다고 했을때, transaction_isolation 에 따라 데이터 조회 결과가 달라짐
        - 트랜잭션이 길어지면 언두영역의 공간이 부족할 수 있음
        - 롤백 실행시 언두영역의 내용으로 변경
        - 트랜잭션 끝날시 언두영역 비움
- 잠금이 없는 일관된 읽기
    - Insert 없는 순수 select 의 경우 undo 영역을 참조
        - → 잠금없이, 일관성 보장
    - 하지만 메모리 영역을 차지하기 때문에, 트랜잭션이 길어지면 느려질 수 있음
- 자동 데드락 감지
    - wait 하고있는 트랜잭션들을 list 로 관리
    - 잠금 대기 그래프를 검사해서 교착상태에 빠지면 그 중 하나를 강제 종료
    - 강제 종료 판단 → 언두 로그 양이 적은 것을 우선 종료 → rollback 의 오버헤드가 더 적음
    - 이노디비 스토리지 엔진은 자기가 관리하는 레코드단의 데드락만 감지가능
        - MySQL 엔진단에서 관리하는 테이블의 데드락은 감지 불가능
        - innodb_table_locks 시스템 변수 활성화시 테이블단의 데드락도 감지가능
    - 데드락 감지시, 다른 락들의 상태를 그대로 두고 (stop-the-world) 감지를 진행하기 때문에, 데드락 감지가 길어질시 시스템에 악영향
- Double Write Buffer
    - 리두 로그 : 변경사항만 저장 (diff와 같은 것)
    - 더티 페이지 flush 중 비정상종료되면, 해당 페이지는 복구 불가능
    - 이를 막기위해 DoubleWrite 버퍼에 먼저쓰기 → 이후에 disk에 랜덤쓰기
        - DoubleWrite버퍼는 이후 clean
- 로그 파일
    - 에러로그
        - my.cnf 에서 정의한 경로
    
    …
