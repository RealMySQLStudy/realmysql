- MySQL 서버
  - MySQL 엔진 : 머리 역할
  - 스토리지 엔진 : 손발 역할
    - 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용가능
    - InnoDB 스토리지 엔진, MyISAM 스토리지 엔진 기본 제공

# 4.1 MySQL 엔진 아키텍처

다른 DMBS에 비해 구조가 독특 → 엄청난 혜택 vs 가끔씩 문제

## 4.1.1 MySQL의 전체구조

![스크린샷, 2023-11-24 오전 10.58.54.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/60444c8d-237b-4f09-a33c-698b4e03baff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.58.54.jpeg)

### 4.1.1.1 MySQL 엔진

- 커넥션 핸들러 : 접속 및 쿼리 요청 처리
- SQL 파서 & 전처리기
- 옵티마이저 : 쿼리의 최적화된 실행
- 요청된 SQL 문장을 분석 Or 최적화 → DBMS의 두뇌에 해당하는 처리 수행
- MySQL 서버에서 하나뿐

### 4.1.1.2 스토리지 엔진

- 실제 데이터를 디스크 스토리지에 저장 or 디스크 스토리지로부터 데이터를 읽어오는 부분 담당
- MySQL 서버에서 스토리지 엔진은 여러 개를 동시 사용 가능

```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

- 테이블이 사용할 스토리지 엔진 지정 → 해당 테이블의 모든 읽기 작업이나 변경 작업은 정의된 스토리지 엔진이 처리
- test_table에 대해 INSERT, UPDATE, DELETE, SELECT… 등의 작업이 발생하면 InnoDB 스토리지 엔진이 처리

### 4.1.1.3 핸들러 API

- MySQL 엔진의 쿼리 실행기에서 스토리지 엔진에 쓰기 or 읽기 요청
- 이러한 요청을 핸들러 요청이라고 함 → 여기서 사용하는 API를 핸들러 API라고 함
- InnoDB 스토리지 엔진은 핸들러 API를 통해서 MySQL 엔진과 데이터를 주고 받는다.

## 4.1.2 MySQL 스레딩 구조

![스크린샷, 2023-11-24 오후 1.47.44.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/f554b653-0fd2-46c5-b8ea-9d989c133562/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.47.44.jpeg)

- MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동
- 포그라운드 스레드와 백그라운드 스레드로 구분

### 4.1.2.1 포그라운드 스레드 (클라이언트 스레드)

- 포그라운드 스레드는 MySQL 서버에 접속된 클라이언트의 수만큼 존재
- 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 데이터를 MySQL의 데이터 버퍼나 캐시로 부터 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리
- MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만 InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리
- 사용자 스레드 = 포그라운드 스레드

### 4.1.2.2 백그라운드 스레드

- InooDB의 백그라운드 작업(MyISAM 경우 해당ㅗㅓ X)
  - 인서트 버퍼를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
- 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드
- 데이터를 읽는 작업은 대부분 클라이언트 스레드에서 처리 → 많은 설정 필요 X
- 데이터를 쓰는 작업은 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.
- 데이터의 쓰기 작업은 지연되어 처리될 수 있지만 읽기 작업은 절대 지연 X → 일반적으로 쓰기 작업을 버퍼링 해서 일괄 처리하는 기능이 탑재 → InnoDB도 동일한 방식
- InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다. → but MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능 X

## 4.1.3 메모리 할당 및 사용 구조

![스크린샷, 2023-11-24 오후 2.27.24.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/0c78aba7-9a33-4933-b607-63c2eb714ba8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.27.24.jpeg)

- MySQL 서버가 시작되면서 운영체제로부터 할당
- 운영체제 종류에 따라 요청된 메모리 공간을 100% 할당 or 해당 공간만큼 예약해두고 필요할 때 조금씩 할당
- MySQL 서버가 사용하는 정확한 메모리의 양을 측정하는 것은 쉽지않다 → Just 단순하게 MySQL의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다고 생각해도 된다.

### 4.1.3.1 글로벌 메모리 영역

- 클라이언드 스레드의 수와 무관하게 하나의 메모리 공간만 할당
- 필요에 따라 2개 이상의 메모리 공간 할당 가능 → 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유
- 글로벌 메모리 영역
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버버

### 4.1.3.2 로컬 메모리 영역 (세션 메모리 영역)

- 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
- 클라이언트가 MySQL 서버에 접속시 서버에서는 클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드를 하나씩 할당 → 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고 불림
- 클라이언트 스레드별로 독립적으로 할당 → 절대 공유되어 사용되지 않는다.
- 최악의 경우(가능성 희박)에는 MySQL 서버가 메모리 부족으로 멈춰 버릴 수도 있기 때문에 적절한 메모리 공간을 설정하는 것이 중요
- 중요 특징 → 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다는 점 → 소트 버퍼나 조인 버퍼와 같은 공간이 그러함.
- 계속 할당된 상태로 남아 있는 공간 → 커넥션 버퍼, 결과 버퍼

## 4.1.4 플로그인 스토리지 엔진 모델

![스크린샷, 2023-11-24 오후 2.40.38.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/644419f2-f387-48ae-95b8-fecf05358b2f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.40.38.jpeg)

- 전문 검색 엔진을 위한 검색어 파서도 플러그인 형태로 개발해서 사용가능
- 사용자의 인증을 위한 Native Authentication, Caching SHA-2 Authentication 등도 모두 플로그인으로 구현되어 제공
- 이미 기본적으로 많은 스토리지 엔진 가지고 있지만 세상의 수많은 사용자의 요구 조건을 만족시키기 위해 기본 스토리지 엔진 이외에 부가적인 기능을 더 제공하는 스토리지 엔진이 필요 → 사용자가 직접 스토리지 엔진 개발 가능

![스크린샷, 2023-11-24 오후 2.43.11.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/07cc788e-f522-45c0-b49b-30bfaaa1364e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.43.11.jpeg)

- 대부분의 작업이 MySQL엔진에서 처리, 마지막 데이터 읽기/쓰기 작업만 스토리지 엔진에서 처리
- MySQL 엔진이 스토리지 엔진을 조정하기 위해 핸들러 사용
- MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야만 한다.
- 실질적인 GROUP BY, ORDER BY 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 ‘쿼리 실행기’에서 처리
- MyISAM , InnoDB 스토리지 엔진에 따라 데이터 읽기/쓰기 작업 처리 방식이 많이 달라짐
- 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야함

```sql
SHOW ENGINES; // MySQL 서버에서 지원되는 스토리지 엔진 확인 명령어
```

## 4.1.5 컴포넌트

- 8.0부터 플러그인 아키텍처를 대체하기 위한 컴포넌트 아키텍처
- 플러그인 단점 보완
  - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플로그인끼리는 통신할 수 없음
  - 플로그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
  - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

## 4.1.6 쿼리 실행 구조

![스크린샷, 2023-11-24 오후 4.39.22.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/7cdb9d03-751b-4cc1-ae04-87871b4f838b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.39.22.jpeg)

### 4.1.6.1 쿼리 파서

- 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업
- 쿼리 문장의 기본 문법 오류는 이과정에서 발견되고 사용자에게 오류 메세지 전달

### 4.1.6.2 전처리기

- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점 체크
- 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정 수행
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.

### 4.1.6.3 옵티마이저

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결장하는 역할
- DMBS의 두뇌에 해당
- 이 책에서는 대부분 옵티마이저가 선택하는 내용을 설명할 것이며, 어떻게 하면 옵티마이저가 더 나은 선택을 할 수 있게 유도하는가를 알려준다. → 중요하고 영향 범위 또한 아주 넓음

### 4.1.6.4 실행엔진

- 실행엔진과 핸들러는 손과 발에 비유 가능
  - 옵티마이저 : 회사의 경영진
  - 실행 엔진 : 중간 관리자
  - 핸들러 : 각 업무의 실무자
- 하는일 - 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정했다고 가정
  1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
  2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
  3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
  4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
  5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
  - 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

### 4.1.6.5 핸들러(스토리지 엔진)

- MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당
- 핸들러 = 스토리지엔진
- MyISAM 테이블 조작 → 핸들러 = MyISAM 스토리지 엔진
- InnoDB 테이블 조작 → 핸들러 = InnoDB 스토리지 엔진

## 4.1.7 복제

- 매우 중요한 역할을 담당
- 16장 복제!

## 4.1.8 쿼리 캐시

- 빠른 응답을 필요로하는 웹 기반의 응용프로그램에서 매우 중요한 역할을 담당했다.
- SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하기 때문에 매우 빠른 성능
- 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두 삭제해야했다. → 심각한 동시 처리 성능 저하 유발
- MySQL 8.0으로 올라오면서 쿼리 캐시는 MySQL 서버의 기능에서 완전히 제거되고, 관련된 시스템 변수도 모두 제거

## 4.1.9 스레드 풀

- 엔터프라이즈 에디션만 기능 제공
- 책에서는 Percona Server에서 제공하는 스레드 풀 기능을 살펴봄 → 플러그인 형태로 작동하게 구현
- 스레프 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
- 실제 서비스에서 눈에 띄는 성능 향상을 보여준 경우는 드물다.
  - 스레드 풀 = 동시에 실행 중인 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능 → 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우에는 쿼리 처리가 더 느려지는 사례도 발생
- Percona Server의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성
- 시스템 변수 thread_pool_size를 변경하여 조정 가능 but CPU 코어의 개수와 맞추는 것이 포로세서 친화도를 높이는데 좋다.
- MySQL 서버가 처리해야할 요청이 생기면 스레드 풀로 처리를 이관 → 이미 처리 중인 작업이 있는 경우 시스템변수에 설정된 개수만큼 추가로 더 받아들여서 처리
- 스레드 그룹의 모든 스레드가 작업 중이면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단
  - 스레드 풀의 타이머 스레드 → 주기적으로 스레드 그룹의 상태 체크
    - thread_pool_stall_limit 시스템 변수에 정의된 밀리초만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 새로운 스레드를 생성해서 스레드 그룹에 추가
    - thread_pool_max_threads 시스템 변수에 설정된 개수를 넘어설 수 없다.
  - 응답 시간에 아주 민감한 서빌스라면 thread_pool_stall_limit 시스템 변수를 적절히 낮춰서 설정해야함 → 그렇다고 0에 가까운 값으로 설정해야 한다면 스레드 풀을 사용하지 않는 편이 나음

## 4.1.10 트랜잭션 지원 메타데이터

- 5.7 버전까지 테이블의 구조를 FRM 파일에 저장. 일부 스토어드 프로그램 또는 파일 기반(.TRN, .TRG, .PAR)으로 관리
- 이러한 파일 기반 의 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중에 서버가 비정상적으로 종료되면 이로간되지 않은 상태로 남는 문제가 발생 → 데이터베이스나 테이블이 깨졌다라고 표현
- 8.0 버전부터 테이블의 구조 정보나 스토어드 프로그램의 코드관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선
- 서버가 작동하는데 기본적으로 필요한 테이블들을 묶어서 시스템 테이블이라고 부름 → 사용자의 인증과 권한에 관련된 테이블
- 이러한 시스템 테이블을 모두 InnoDB 스토리지 엔진을 사용하도록 개선, 시스템 테이블과ㅣ 데이터 딕셔너리 정보를 모두 모아서 mysql DB에 저장하고 있다.
- mysql DB는 통째로 mysql.ibd라는 이름의 테이블스페이스에 저장
- 서버가 비정상적으로 종료된다고 하더라도 스키마 변경이 완전한 성공 또는 완전한 실패로 정리된다.

# 4.2 InnoDB 스토리지 엔진 아키텍처

- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공 → 높은 동시성 처리가 가능, 안정적이며, 성능이 뛰어남

![스크린샷, 2023-11-27 오전 10.50.37.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/bcb35761-5834-4ca2-8a01-e5613d4a0852/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.50.37.jpeg)

## 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. → 프라이머리 키 값의 순서대로 디스크에 저장된다.
  - 클러스터링 : **서로 유사한 속성을 갖는 데이터를 같은 군집으로 묶어주는 작업**
- 프라이머리 키 = 클러스터링 인덱스 → 프라이머리키를 이용한 레인지 스캔은 상당히 빨리 처리된다.
- 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정
- 클러스터링 키 → 8.8절 클러스터링 인덱스에서 상세히 설명

## 4.2.2 외래 키 지원

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능
- 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의
  - 데드락(deadlock)은 **두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태**
- foreign_key_checks 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다. → 레코드 적재, 삭제 등의 작업도 부가적인 체크가 필요 없기 때문에 훨씬 빠른 처리 가능

```sql
SET foreign_key_checks=OFF;

-- // 작업 실행

SET foregin_key_checks=ON;
```

- 외래 키 관계를 가진 부모 테이블의 레코드를 삭제했다면 반드시 자식 테이블의 레코드도 삭제해서 일광성을 맞춰준 후 다시 외래 키 체크 기능을 활성화

## 4.2.3 MVCC(Multi Version Concurrency Control : 동시성 컨트롤)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 가장 큰 목적 : 잠금을 사용하지 않는 일관된 읽기를 제공
- 언두 로그를 이용해 이 기능을 구현
- 멀티 버전 → 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미
- 격리 수준이 READ_COMMITTED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경이 처리되는 과정
    <aside>
    💡 격리수준(isolation level)이란 **트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 수준**입니다. 즉, 한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도를 의미합니다. 레벨이 높아질수록 트랜잭션간 고립정도가 높아지며, 성능저하도 야기됩니다
    
    </aside>
    
    ```sql
    CREATE TABLE member (
    	m_id INT NOT NULL,
    	m_name VARCHAR(20) NOT NULL,
    	m_area VARCHAR(100) NOT NULL,
    	PRIMARY KEY (m_id),
    	INDEX ix_area (m_area)
    );
    
    INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
    COMMIT;
    ```
    
    ![스크린샷, 2023-11-27 오후 1.34.10.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/426e68b9-180c-4601-a820-89bd2eb87cdb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.34.10.jpeg)
    
    ```sql
    UPDATE member SET m_area='경기' WHERE m_ud=12;
    ```
    
    ![스크린샷, 2023-11-27 오후 1.35.15.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/bdd6cdb7-228e-4c7d-8be8-c192d05643b3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.35.15.jpeg)
    
    - 디스크의 데이터 파일에는 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다.(일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방)
    - COMMIT이나 롤백이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회하면 어디있는 데이터를 조회할까?
    
    ```sql
    SELECT * FROM member WHERE m_id=12;
    ```
    
    - 시스템 변수(transaction_isolation)에 설정된 격리 수준에 따라 다르다
        - READ_UNCOMMITTED : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환
            
            → 커밋이 됐든 아니든 변경된 상태의 데이터를 반환
            
        - READ_COMMITTED or 그 이상의 격리 수준 : InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환
    - 이 상태에서 COMMIT하면 지금의 상태를 영구적인 데이터로 만들어 버린다. → 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니다. 언두 영역을 필요로하는 트랜잭션이 더는 없을 때 삭제된다.
    - 이 상태에서 ROLLBACK하면 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고 언두 영역의 내용을 삭제

## 4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행
- InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능
- 격리 수준이 SERIALIZABLE이 나닌 READ_UNCOMMITTED나 READ_COMMITTED, REPEATABLE_READ 수준인 경우 INSER와 연결되지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

![스크린샷, 2023-11-27 오후 1.50.41.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/f7223f35-bfa2-4aec-864f-8dfaca85abe1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.50.41.jpeg)

- 특정 사용자가 레코드를 변경하고 커밋을 수행하지 않아도 이 변경이 다른 사용자의 SELECT 작업을 방해하지 않는다. 이를 ‘잠금 없는 일관된 읽기’라고 표현 → InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.
- 오랜 시간동안 활성상태인 트랜잭션으로 인해 서버가 느려지거나 문제가 발생할 때가 가끔 존재 → 일관된 읽기를 위해 언두로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제 → 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.

## 4.2.5 자동 데드락 감지

- InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있다.
- 해당 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 장제 종료
- 어느 트랜잭션을 강제 종료할 것인지를 판단 기준 → 언두 로그 양 → 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상
- 언두 레코드를 적게 가졌다 → 롤백을 해도 언두 처리를 해야할 내용이 적다 → 서버 부하도 덜 유발
- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 볼 수가 없어서 데드락 감지가 불확실할 수도 있는데, innodb_table_locks 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지 가능 → 특별한 이유가 없다면 innodb_table_locks 시스템 변수 활성화
- 일반적으로 데드락 감지 스레드가 트랜잭션의 잠금 목록을 검사해서 데드락을 찾아내는 작업은 부담 X → 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드 느려짐 → 데드락 감지 스레드는 잠금목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾음 → 데드락 감지 스레드가 느려지면 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향 미침
- 문제를 해결하기 위해 innodb_deadlock_detect 시스템 변수 제공 → OFF로 설정하면 데드락 감지 스레드 작동 X → InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황이 발생해도 중재하지 않기 때문에 무한정 대기
- innodb_lock_wait_timeout 시스템 변수를 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지 반환 → 초 단위로 설정할 수 있고, 설정 시간 동안 잠금을 획득하지 못하면 쿼리는 실패하고 에러 반환
- 데드락 감지 스레드가 부담되어 innodb_deadlock_detect를 OFF로 설정해 비활성화하는 경우 innodb_lock_wait_timeout을 기본값인 50초 보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장

## 4.2.6 자동화된 장애 복구

- InnoDB 스토리지 엔진은 매우 견과해서 데이터 파일이 손상되거나 서버가 시작되지 못하는 경우는 거의 발생하지 않음
- but 서버와 무관하게 디스크나 서버 하드웨어 이슈로 엔진이 자동으로 복구를 못하는 경우 발생
- InnoDB 데이터 파일은 기본적으로 서버가 시작될 때 항상 자동 복구를 수행 → 이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 서버 종료
- 서버 설정 파일에 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 시작해야함 → 설정 시 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행 할 수 있게 한다.
  - InnoDB의 로그 파일이 손상됐다면 6으로 설정
  - InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정
  - 어떤 부분인지 알 수 없다면 1~6까지 변경하면서 재시작 값이 커질수록 그만큼 심각한 상황이어서 데이터 손실 가능성이 커지고 복구가능성은 적어진다.
- InnoDB 테이블이 인식된다면 mysqldump를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB와 테이블을 다시 생성하는 것이 좋다.
- innodb_force_recovery가 0이 아닌 복구 모드에서는 SELECT 이외의 INSERT나 UPDATE, DELETE 같은 쿼리 수행 불가

- 1(SRV_FORCE_IGNORE_CORRUPT)
- 2(SRV_FORCE_NO_BACKGROUND)
- 3(SRV_FORCE_NO_TRX_UNDO)
- 4(SRV_FORCE_NO_IBUF_MERGE)
- 5(SRV_FORCE_NO_UNDO_LOG_SCAN)
- 6(SRV_FORCE_NO_LOG_REDO)

## 4.2.7 InnoDB 버퍼 풀 (가장 핵심적인 부분!!!)

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이한다. → 먼소리고
- INSERT,UPDATE,DELETE처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킴 but 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

### 4.2.7.1 버퍼 풀의 크기 설정

- 전체 물리 메모리의 80프로를 InnoDB 버퍼풀로 설정하라는 게시물 → 믿지마
- 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해야함
- MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없다 but 아주 독특한 경우 레코드 버퍼가 상당한 메모리 사용하기도함
- 레코드 버퍼는 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용되는 공간을 말함
- 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해 질 수 있음
- MySQL 서버가 사용하는 레코드 버퍼 공간은 별도 설정 불가 → 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블 개수에 따라 결정
- 이 버퍼 공간은 동적으로 해제되기도 하므로 정확히 필요한 메모리 공간의 크기를 계산 불가
- 5.7 버전부터 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선 → 크기를 적절히 작은 값으로 설정해 조금씩 상황을 봐 가면서 증가시키는 방법이 최적
- 이미 MySQL 서버 사용 중 → 그 서버의 메모리 설정 기준으로 InnoDB 버퍼 풀 크기 설정
- 처음 MySQL 서버 사용 → 다음과 같은 방법으로 설정
  - 운영체제의 전체 메모리 공간이 8GB 미만이라면 50% 정도만 버퍼 풀로 설정. 나머지 메모리 공간은 MySQL 서버와 운영체제, 다른프로그램이 사용할 수 있는 공간으로 확보해주는 것이 좋다.
  - 메모리 8GB 이상 → InnoDB 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해서 조금씩 올려가며 최적점 찾기
  - 전체 메모리 공간이 50GB 이상 → 15GB ~ 30GB 정도를 운영체제와 다른 응용 프로그램을 위해서 남겨두고 나머지를 InnoDB 버퍼풀로 할당 (InnoDB = 20 ~ 35G 할당)
- InnoDB 버퍼 풀 크기 변경은 크리티컬 → 서버가 한가한 시점을 골라서 진행
- 가능하면 버퍼 풀의 크기를 줄이는 작업은 하지말자.
- 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되는데, 이는 버퍼 풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용 → 버퍼 풀의 크기를 줄이거나 늘릴 때는 128MB 단위로 처리

### 4.2.7.2 버퍼 풀의 구조

- InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장
- 페이지 크기 조각을 관리하기 위해 LRU리스트와 플러시 리스트, 프리 리스트 3개의 자료 구조 관리
- 프리 리스트는 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야하는 경우 사용된다.

![스크린샷, 2023-11-27 오후 3.43.41.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/4476df12-ffe7-4d67-a111-eaa2449bae4c/bd4838a5-764b-4e7b-9fd5-597f437b743c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.43.41.jpeg)

- 엄밀하게 LRU와 MRU 리스트가 결합된 형태
  - LRU(Least Recently Used)는 가장 오래 전에 마지막으로 사용했던 페이지를 버퍼에서 내보내는 알고리즘
  - MRU(Most Recently Used)는 가장 최근에 연산이 끝난 블록을 버퍼에서 버리는 알고리즘
- Old 서브리스트 영역은 LRU에 해당, New 서브리스트는 MRU에 해당
  - Old 서브리스트 → 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것
- InnoDB 스토리지 엔진에서 데이터를 찾는 과정
  1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검색
     1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
     2. 해당 테이블의 인덱스를 이용해 버퍼 풀에서 페이지를 검색
     3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
  2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
  3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU헤더 부분으로 이동
  4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고(Aging) 결국 해당 페이지는 버퍼 풀에서 제거
  5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
- 자주 사용되는 데이터 페이지는 버퍼풀의 MRU 영역에서 계속 살아남게 되고, 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 LRU의 끝으로 밀려나 결국 버퍼 풀에서 제

- 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지 = 더티 페이지
- 플러시 리스트는 더티페이지의 변경 시점 기준의 페이지 목록을 관리
- 한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록돼야함
- 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영

### 4.2.7.3 버퍼 풀과 리두 로그

- 버퍼 풀 → 메모리 크게 설정하면 할수록 쿼리의 성능이 빨라짐
- InnoDB 버퍼 풀은 데이터 베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링 두가지 용도가 존재
  - 데이터 캐시
  - 쓰기 버퍼링
- 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상 시키는 것!
- 쓰기 버퍼링 기능까지 향상 시키려면 버퍼 풀과 리두 로그와의 관계를 먼저 이해해야함
- 버퍼풀은 가진다.
  - 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지
  - INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 더티 페이지
- 더티 페이지는 디스크와 버퍼 풀의 데이터 상태가 다르기 때문에 언젠가는 디스크로 기록돼야 한다.
- 더티 페이지는 버퍼 풀에 무한정 머무를 수 없다.
- InnoDB 스토리지 엔진에서 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용
  - 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다.
  - 그래서 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야하는데 재사용 불가능한 공간을 활성 리두 로그라고 한다.
  - 즉, 활성 리두 로그 = 재사용 불가!
- 리두 로그 파일의 공간 → 계속 순환되어 재사용 → but 매번 기록될 때마다 로그 포지션 계속 증가된 값을 가짐
- 이 증가된 로그 포지션 값을 = LSN이라고 부름 (Log Sequence Number)
- 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화 → 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점
- InnoDB 버퍼 풀의 더티 페이지 = 특정 리두 로그 엔트리와 관계를 가짐
- 체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화 돼야한다.
- 체크포인트 LSN보다 작은 LSN 값을 가진 리두 로그 엔트리도 디스크로 동기화돼야함

### 4.2.7.4 버퍼 풀 플러시

- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행
  - 플러시 리스트 플러시
  - LRU 리스트 플러시

### 4.2.7.4.1 플러시 리스트 플러시

- 스토리지 엔진 → 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워하함 → wyh? 리두 로그 공간 재활용을 위해
- 오래된 리두 로그 공간이 지워지려면 버퍼풀의 더티페이지가 먼저 디스크로 동기화 돼야함.
- 이를 위해 스토리지 엔진은 주기적으로 플러시 리스트 플러시 함수를 호출하여 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업 수행
- 이때 언제부터 얼마나 많은 더티페이지를 한번에 디스크로 기록하느냐에 따라 사용자의 쿼리 처리가 악영향을 받지 않으면서 부드럽게 처리
- 클리너 스레드 → 개수 조정가능
- 하나의 클리너 스레드 하나의 버퍼 풀 인스턴스 처리
- 더티페이지 가질수있는 비율 설정 가능
- 더티페이지 많을 수록 디스크 쓰기 작업을 버퍼링함으로써 여러번의 디스크쓰기를 한벙으로 줄이는 효과!
- but 더티페이지 많을수록 디스크 쓰기 폭발 현상 발생 가능성 높다.

### 4.2.7.4.2 LRU 리스트 플러시

- 공간 확보를 위해 LRU 리스트 플러시 함수 사용
- 스토리지 엔진 LRU리스트의 페이지들을 스캔하면서 더티페이지는 디스크에 동기화, 클린 페이지는 즉시 프리리스트 페이지로 옮김

### 4.2.7.5 버퍼 풀 상태 백업 및 복구

- 버퍼풀은 쿼리의 성능에 매우 밀접
- 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태 = 워밍업
- 버퍼 풀이 잘 워밍업된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보임
- 5.6버전부터 버퍼 풀 덤프 및 적재 기능이 도입 → 셧다운후 버퍼 풀 상태 백업 가능

### 4.2.7.6 버퍼 풀 적재 내용 확인

## 4.2.8 Double Write Buffer

## 4.2.9 언두로그

## 4.2.10 체인지 버퍼

## 4.2.11 리두 로그 및 로그 버퍼

### 4.2.11.1 리두 로그 아카이빙

### 4.2.11.2 리두 로그 활성화 및 비활성화

## 4.2.12 어댑티브 해시 인덱스

## 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

# 4.3 MyISAM 스토리지 엔진 아키텍처

## 4.3.1 키 캐시

## 4.3.2 운영체제의 캐시 및 버퍼

## 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조

# 4.4 MySQL 로그 파일

## 4.4.1 에러 로그 파일

### 4.4.1.1 MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지

### 4.4.1.2 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지

### 4.4.1.3 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지

### 4.4.1.4 비정상적으로 종료된 커넥션 메시지

### 4.4.1.5 InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지

### 4.4.1.6 MySQL의 종료 메시지

## 4.4.2 제너럴 쿼리 로그 파일

## 4.4.3 슬로우 쿼리 로그

### 4.4.3.1 슬로우 쿼리 통계

### 4.4.3.2 실행 빈도 및 누적 실행 시간순 랭킹

### 4.4.3.3 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보
